//authService.js
const asyncHandler= require('express-async-handler');
const jwt= require('jsonwebtoken');
const bcrypt= require('bcrypt');
const  crypto  = require('crypto');

const UserModel= require('../models/userModel');
const ApiFeatures = require('../utils/apiFeatures');
const ApiError = require('../utils/ApiError');

exports.signUp= asyncHandler(async(req,res,next)=>{
//create user
const user= await UserModel.create({
    name: req.body.name,
    email: req.body.email,
    password: req.body.password,
})
//create a jwt for this user
const token= jwt.sign({userId: user._id}, process.env.secretKey,{expiresIn:'1d'});
//return the response to client side
res.status(201).json({data: user, token});
});


exports.logIn= asyncHandler( async(req,res,next)=>{
    //1) check that email exist and the password is correct
    const user= await UserModel.findOne({email:req.body.email});
    if(!user || !(await bcrypt.compare(req.body.password, user.password)))
        return next(new Error('invalid email or password'));

    //2) generate a token for this user
    const token= jwt.sign({userId: user._id},process.env.secretKey,{expiresIn: '1d'});
    
    //3) send response back to client side.
    res.status(200).json({data:user, token})
});

// @desc make sure the user is logged in
exports.protect= asyncHandler(async(req,res,next)=>{
    // 1) cheak weather a token is sent in the headers.
    let token;
    if(req.headers.authorization && req.headers.authorization.startsWith('Bearer'))
        token= req.headers.authorization.split(' ')[1];
    if(!token)
        return next(new ApiError('Not logged in, please logIn first',401));

    // 2) verify weather this token is valid(not changed and not expired).
    const decoded= jwt.verify(token, process.env.secretKey); //?
        
    // 3) cheak if user of this token still exists.
    const user= await UserModel.findById(decoded.userId);
    if(!user)
        return next(new ApiError('The user that belong to this token does no longer exist'), 401);
    
    // 4) cheak if user change his password after token is created.
    if(user.passwordChangedAt)
    {
        const passwordChangedAtTimeStamp= parseInt(user.passwordChangedAt.getTime()/1000, 10); //?
        if(passwordChangedAtTimeStamp > decoded.iat)
            return next(new ApiError('password changed. Please logIn again'),401);
    }
    req.user= user;  //?
    next();
});

exports.allowedTo= (...roles)=>
    asyncHandler(async(req,res,next)=>{
        // cheack weather user.role exist in roles
        if(!roles.includes(req.user.role))  //?
            return next(new ApiError('you are not permitted to access this route',403));
        next();
    });

exports.forgotPassword= asyncHandler(async(req,res,next )=>{
    // 1) Get user by email (to ensure email is correct).
    const user= await UserModel.findOne({email: req.body.email});
    if(!user)
        return next(new ApiError(`No user for this email ${req.body.email}`));

    // 2) If user exists, Generate random 6 digits and save it in db.
    const resetCode= Math.floor(100000 + Math.random() * 900000).toString();

    const hashedResetCode = crypto
        .createHash('sha256')
        .update(resetCode)
        .digest('hex');

    //save the hashed passwordResetCode in db
    user.passwordResetCode= hashedResetCode;
    //save the expiry date of the passwordResetCode in db (in milSec)
    user.passwordResetExpires= Date.now()+ 10 * 60 * 1000;
    user.passwordResetVerified= false;
    console.log(resetCode);
    console.log(hashedResetCode);
    user.save();
    // 3) Send the reset code via email.
});




//notices
/*
The protect function is wrapped with asyncHandler.
This utility catches any error that occurs in an asynchronous function
and forwards it to the next middleware by calling next(error).
Any error passed to next() middleware is handled by the golbalError.
In summary, the error generated by jwt.verify() is caught by asyncHandler and
passed to the golbalError middleware, which is responsible for sending a 
consistent error response to the client based on weather we are in dev or prod environment.
//////////////////////
decoded=> contains the decoded token containing the payload and the expire_date
//////////////////////
parseInt()=>  ensure that the result is an integer by discarding any decimal part.
10 => called the radix which is the base of the number system.
this means that the number being parsed is in decimal (base-10).
//////////////////////
req.user= user; ==> add user object to req since we will need it in the allowedTo middleware
//////////////////////
req.user--> user object has been added to req in the end of the 'protect' middlewaare
*/

